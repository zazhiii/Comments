# 1. 登录
## 基于Session实现登录
1. 发送短信验证码
   1. 接收参数：手机号
   2. 校验手机号是否合法
   3. 生成短信验证码，保存到Session中
   4. 发送短信验证码
2. 短信验证码登录、注册
   1. 接收参数：手机号、验证码
   2. 校验该手机号对应的验证码是否一致
   3. 根据手机号查询用户是否存在，存在则登录，不存在则注册
   4. 保存用户到Session中
3. 登录状态校验(拦截器实现)
   1. 接受Cookie中的session_id
   2. 从Session中获取用户信息
   3. 如果用户信息不存在，则未登录，否则已登录
   4. 保存用户信息到ThreadLocal中
> ThreadLocal中不宜存放过多数据，他是基于内存的会对内存造成压力

> BeanUtils.copyProperties()的使用

> 使用Session实现登录会在集群环境下存在问题，
> 因为Session是存储在单个服务器上的，
> 如果多台服务器没有共享Session，会造成数据不一致
> 而每一台服务器都存储一份Session会造成内存浪费

## 基于 Redis 实现登录
1. 发送验证码
> 这个时候验证码不再存储在Session中，而是存储在Redis中
> 
> 注意：
> 1. 用手机号作为code的key（保证唯一性），用code作为value
>
> 2. 给 code 设置一个过期时间
> 
> 3. 给key设置一个前缀，用于区分不同的业务

2. 登录

> 校验验证码不再从 Session 中获取，而是从 Redis 中获取

> 登录成功之后，将用户信息存储到 Redis 中并设置过期时间。

> 需要生成一个唯一的 token 作为 key，同时他也是登录凭证，需要返回给前端

3. 登录状态校验
> 从请求头中获取 token，然后从 Redis 中获取用户信息
> 
> 如果用户信息不存在，则未登录，否则已登录
> 
> 「token过期时间刷新」

> token刷新问题：需要再添加一个RefreshTokenIntercepter拦截器拦截所有请求来刷新token

# 2. 缓存
1. 查询时，先判断缓存中是否存在数据，存在则直接返回
2. 如果缓存中不存在数据，则查询数据库
3. 若查到数据，则将数据存入缓存
4. 返回数据
## 缓存更新策略
1. 内存淘汰
2. 超时剔除
3. 主动更新
> 对于低一致性需求：选用内存淘汰策略 + 超时剔除策略
> 
> 对于高一致性需求：选用主动更新策略 + 超时剔除策略。对于写入操作，先修改数据库，再删除缓存。 使用事务保证数据库与缓存操作的原子性
>
## 缓存穿透
缓存穿透：查询一个一定不存在的数据，由于缓存不命中，每次都要去查询数据库，导致数据库压力过大

解决方案：
1. 采用「布隆过滤器」，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力
2. 「缓存空对象」如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟