# 1. 登录
## 基于Session实现登录
1. 发送短信验证码
   1. 接收参数：手机号
   2. 校验手机号是否合法
   3. 生成短信验证码，保存到Session中
   4. 发送短信验证码
2. 短信验证码登录、注册
   1. 接收参数：手机号、验证码
   2. 校验该手机号对应的验证码是否一致
   3. 根据手机号查询用户是否存在，存在则登录，不存在则注册
   4. 保存用户到Session中
3. 登录状态校验(拦截器实现)
   1. 接受Cookie中的session_id
   2. 从Session中获取用户信息
   3. 如果用户信息不存在，则未登录，否则已登录
   4. 保存用户信息到ThreadLocal中
> ThreadLocal中不宜存放过多数据，他是基于内存的会对内存造成压力

> BeanUtils.copyProperties()的使用

> 使用Session实现登录会在集群环境下存在问题，
> 因为Session是存储在单个服务器上的，
> 如果多台服务器没有共享Session，会造成数据不一致
> 而每一台服务器都存储一份Session会造成内存浪费

## 基于 Redis 实现登录
1. 发送验证码
> 这个时候验证码不再存储在Session中，而是存储在Redis中
> 
> 注意：
> 1. 用手机号作为code的key（保证唯一性），用code作为value
>
> 2. 给 code 设置一个过期时间
> 
> 3. 给key设置一个前缀，用于区分不同的业务

2. 登录

> 校验验证码不再从 Session 中获取，而是从 Redis 中获取

> 登录成功之后，将用户信息存储到 Redis 中并设置过期时间。

> 需要生成一个唯一的 token 作为 key，同时他也是登录凭证，需要返回给前端

3. 登录状态校验
> 从请求头中获取 token，然后从 Redis 中获取用户信息
> 
> 如果用户信息不存在，则未登录，否则已登录
> 
> 「token过期时间刷新」

> token刷新问题：需要再添加一个RefreshTokenIntercepter拦截器拦截所有请求来刷新token

# 2. 缓存
1. 查询时，先判断缓存中是否存在数据，存在则直接返回
2. 如果缓存中不存在数据，则查询数据库
3. 若查到数据，则将数据存入缓存
4. 返回数据
## 缓存更新策略
1. 内存淘汰
2. 超时剔除
3. 主动更新
> 对于低一致性需求：选用内存淘汰策略 + 超时剔除策略
> 
> 对于高一致性需求：选用主动更新策略 + 超时剔除策略。对于写入操作，先修改数据库，再删除缓存。 使用事务保证数据库与缓存操作的原子性
>
## 缓存穿透
缓存穿透：查询一个一定不存在的数据，由于缓存不命中，每次都要去查询数据库，导致数据库压力过大

解决方案：
1. 采用「布隆过滤器」，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力
2. 「缓存空对象」如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟

## 缓存雪崩
缓存雪崩：是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：
1. TTL添加随机值
2. 限流降级
3. Redis集群
4. 限流降级

## 缓存击穿
缓存击穿：是指一个key非常热点，在不停的扛着大并发，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库

解决方案：
1. 互斥锁，通过 Redis 中 setnx 实现
2. 逻辑过期

# 优惠券秒杀
## 全局唯一ID
1. Redis 自增
>通过redis实现：用 long 类型，符号位（1bit）+ 时间戳（31bit） + 序列号（32bit）
> 
> 每天一个 key ，方便统计


2. UUID
3. snowflake 雪花算法
4. 数据库自增

## 秒杀下单
功能应该在一个事务中完成
1. 判断是否在活动时间内
2. 判断库存是否充足
3. 修改库存
4. 生成订单

## 超卖问题

1. 乐观锁：认为线程问题不一定会发生，所以在操作之前不加锁，而是在操作时再判断是否发生线程问题
   1. 通过「版本号」实现乐观锁
   2. 通过「CAS」实现乐观锁：`compareAndSet` 更新时的库存数量必须是查询的库存数量（库存代替版本号）
2. 悲观锁：认为线程问题一定会发生，所以在操作之前先加锁（`Synchronized`，`Lock`）

## 一人一单
注意：
1. 释放锁的时机
2. 事务生效

## 分布式锁，解决集群环境下的并发问题
JVM锁：每个 JVM 都有一个锁监视器，只能在同一个JVM中起作用，无法解决集群环境下的并发问题
分布式锁：满足分布式系统或集群模式下「多进程可见」并且「互斥」的锁，满足高可用、高性能、安全性……的要求

常见实现：
1. 数据库
2. Redis
> setnx，设置expire保证锁释放（获取锁和设置过期时间应该保证原子性，通过一条命令即可实现）
> 
> 问题：锁超时，但业务还未执行完，导致锁被释放，其他线程获取锁，导致并发问题
> 
> 解决：1. 在获取锁时存入线程标识（可用UUID，单纯用线程id会在集群时有问题） 2. 释放锁时校验线程标识
> 
> 进一步问题：释放锁时被阻塞，锁超时释放，其他线程获取锁，阻塞结束后锁又被释放
> 
> 解决：保证判断是否是自己的锁和释放锁是原子操作，可以使用 Lua 脚本
> 

3. Zookeeper


